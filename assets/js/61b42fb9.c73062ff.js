"use strict";(globalThis.webpackChunkai_spec_driven_book_with_rag_chatbot_frontend=globalThis.webpackChunkai_spec_driven_book_with_rag_chatbot_frontend||[]).push([[781],{8453(n,e,a){a.d(e,{R:()=>s,x:()=>r});var i=a(6540);const o={},t=i.createContext(o);function s(n){const e=i.useContext(t);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:s(n.components),i.createElement(t.Provider,{value:e},n.children)}},8798(n,e,a){a.r(e),a.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"isaac-ai-brain/nav2-path-planning-humanoid","title":"Nav2 Path Planning for Humanoid Robots","description":"Introduction","source":"@site/docs/isaac-ai-brain/nav2-path-planning-humanoid.md","sourceDirName":"isaac-ai-brain","slug":"/isaac-ai-brain/nav2-path-planning-humanoid","permalink":"/docs/isaac-ai-brain/nav2-path-planning-humanoid","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/isaac-ai-brain/nav2-path-planning-humanoid.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Isaac ROS for VSLAM and Navigation","permalink":"/docs/isaac-ai-brain/isaac-ros-vslam-navigation"},"next":{"title":"Voice-to-Action with OpenAI Whisper","permalink":"/docs/vla-llm-integration/voice-to-action-whisper"}}');var o=a(4848),t=a(8453);const s={},r="Nav2 Path Planning for Humanoid Robots",l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Understanding Humanoid Navigation Challenges",id:"understanding-humanoid-navigation-challenges",level:2},{value:"Differences from Wheeled Navigation",id:"differences-from-wheeled-navigation",level:3},{value:"Key Considerations",id:"key-considerations",level:3},{value:"Nav2 Architecture for Humanoid Robots",id:"nav2-architecture-for-humanoid-robots",level:2},{value:"Core Components",id:"core-components",level:3},{value:"Humanoid-Specific Modifications",id:"humanoid-specific-modifications",level:3},{value:"Custom Plugins for Humanoid Navigation",id:"custom-plugins-for-humanoid-navigation",level:2},{value:"Humanoid Global Planner",id:"humanoid-global-planner",level:3},{value:"Footstep Planner Integration",id:"footstep-planner-integration",level:3},{value:"Balance Controller Integration",id:"balance-controller-integration",level:3},{value:"Integration with Isaac Sim",id:"integration-with-isaac-sim",level:2},{value:"Simulation Setup for Humanoid Navigation",id:"simulation-setup-for-humanoid-navigation",level:3},{value:"Nav2 Configuration for Isaac Sim",id:"nav2-configuration-for-isaac-sim",level:3},{value:"Dynamic Obstacle Avoidance for Humanoids",id:"dynamic-obstacle-avoidance-for-humanoids",level:2},{value:"Humanoid-Specific Collision Avoidance",id:"humanoid-specific-collision-avoidance",level:3},{value:"Multi-Terrain Navigation",id:"multi-terrain-navigation",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Real-time Navigation Considerations",id:"real-time-navigation-considerations",level:3},{value:"Memory and Computation Optimization",id:"memory-and-computation-optimization",level:3},{value:"Practical Examples",id:"practical-examples",level:2},{value:"Example 1: Simple Humanoid Navigation",id:"example-1-simple-humanoid-navigation",level:3},{value:"Example 2: Complex Navigation with Obstacle Avoidance",id:"example-2-complex-navigation-with-obstacle-avoidance",level:3},{value:"Troubleshooting and Validation",id:"troubleshooting-and-validation",level:2},{value:"Common Navigation Issues",id:"common-navigation-issues",level:3},{value:"Validation Methods",id:"validation-methods",level:3},{value:"Exercises",id:"exercises",level:2},{value:"Summary",id:"summary",level:2},{value:"Next Steps",id:"next-steps",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"nav2-path-planning-for-humanoid-robots",children:"Nav2 Path Planning for Humanoid Robots"})}),"\n",(0,o.jsx)(e.h2,{id:"introduction",children:"Introduction"}),"\n",(0,o.jsx)(e.p,{children:"This chapter explores the application of Nav2 (Navigation 2) for bipedal humanoid path planning. Nav2 is the standard navigation framework for ROS 2, but requires specialized configuration and custom plugins to effectively handle the unique challenges of humanoid locomotion. You'll learn how to adapt Nav2 for humanoid robots, implement footstep planning, and ensure stable navigation with balance considerations."}),"\n",(0,o.jsx)(e.p,{children:"The chapter will cover the fundamentals of humanoid navigation, custom Nav2 plugins for bipedal locomotion, and integration with Isaac Sim for realistic testing. We'll also explore advanced topics like dynamic obstacle avoidance and multi-terrain navigation specific to humanoid robots."}),"\n",(0,o.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,o.jsx)(e.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Configure Nav2 for bipedal humanoid navigation with balance considerations"}),"\n",(0,o.jsx)(e.li,{children:"Implement custom plugins for humanoid-specific navigation requirements"}),"\n",(0,o.jsx)(e.li,{children:"Integrate footstep planning with path planning for stable locomotion"}),"\n",(0,o.jsx)(e.li,{children:"Handle dynamic obstacle avoidance for humanoid robots"}),"\n",(0,o.jsx)(e.li,{children:"Optimize navigation performance for real-time humanoid operation"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,o.jsx)(e.p,{children:"Before starting this chapter, you should have:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Completed the Isaac Sim and Isaac ROS chapters (Module 3, Chapters 1-2)"}),"\n",(0,o.jsx)(e.li,{children:"Understanding of ROS 2 navigation concepts"}),"\n",(0,o.jsx)(e.li,{children:"Basic knowledge of humanoid kinematics and bipedal locomotion"}),"\n",(0,o.jsx)(e.li,{children:"Familiarity with control theory concepts (ZMP, center of mass)"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"understanding-humanoid-navigation-challenges",children:"Understanding Humanoid Navigation Challenges"}),"\n",(0,o.jsx)(e.h3,{id:"differences-from-wheeled-navigation",children:"Differences from Wheeled Navigation"}),"\n",(0,o.jsx)(e.p,{children:"Humanoid navigation presents unique challenges compared to traditional wheeled robots:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Balance Requirements"}),": Humanoid robots must maintain balance during navigation"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Footstep Planning"}),": Requires explicit footstep planning for stable locomotion"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Multi-terrain Navigation"}),": Must handle stairs, slopes, and uneven terrain"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Dynamic Stability"}),": Balance can be affected by external forces and obstacles"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Complex Kinematics"}),": 6+ DOF legs require sophisticated motion planning"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"key-considerations",children:"Key Considerations"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Zero Moment Point (ZMP)"}),": Critical for maintaining balance during walking"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Capture Point"}),": Determines where to place feet for stability"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Center of Mass (CoM)"}),": Must be carefully controlled during navigation"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Foot Placement"}),": Strategic foot placement for obstacle avoidance and stability"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"nav2-architecture-for-humanoid-robots",children:"Nav2 Architecture for Humanoid Robots"}),"\n",(0,o.jsx)(e.h3,{id:"core-components",children:"Core Components"}),"\n",(0,o.jsx)(e.p,{children:"Nav2 consists of several key components that need adaptation for humanoid navigation:"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Global Planner"}),": Generates high-level path considering humanoid kinematics"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Local Planner"}),": Creates detailed footstep plans for immediate navigation"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Controller"}),": Executes footstep plans with balance control"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Recovery Behaviors"}),": Specialized recovery for humanoid-specific failures"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Lifecycle Manager"}),": Coordinates navigation state transitions"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"humanoid-specific-modifications",children:"Humanoid-Specific Modifications"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-yaml",children:'# nav2_params_humanoid.yaml\namcl:\n  ros__parameters:\n    use_sim_time: true\n    alpha1: 0.2\n    alpha2: 0.2\n    alpha3: 0.2\n    alpha4: 0.2\n    alpha5: 0.2\n    base_frame_id: "base_footprint"\n    beam_skip_distance: 0.5\n    beam_skip_error_threshold: 0.9\n    beam_skip_threshold: 0.3\n    do_beamskip: false\n    global_frame_id: "map"\n    lambda_short: 0.1\n    laser_likelihood_max_dist: 2.0\n    laser_max_range: 100.0\n    laser_min_range: -1.0\n    laser_model_type: "likelihood_field"\n    max_beams: 60\n    max_particles: 2000\n    min_particles: 500\n    odom_frame_id: "odom"\n    pf_err: 0.05\n    pf_z: 0.99\n    recovery_alpha_fast: 0.0\n    recovery_alpha_slow: 0.0\n    resample_interval: 1\n    robot_model_type: "nav2_amcl::DifferentialMotionModel"\n    save_pose_rate: 0.5\n    sigma_hit: 0.2\n    tf_broadcast: true\n    transform_tolerance: 1.0\n    update_min_a: 0.2\n    update_min_d: 0.1\n    z_hit: 0.5\n    z_max: 0.05\n    z_rand: 0.5\n    z_short: 0.05\n\nbt_navigator:\n  ros__parameters:\n    use_sim_time: true\n    global_frame: "map"\n    robot_base_frame: "base_link"\n    odom_topic: "/odom"\n    default_bt_xml_filename: "humanoid_navigator_bt.xml"\n    plugin_lib_names:\n    - nav2_compute_path_to_pose_action_bt_node\n    - nav2_follow_path_action_bt_node\n    - nav2_back_up_action_bt_node\n    - nav2_spin_action_bt_node\n    - nav2_wait_action_bt_node\n    - nav2_clear_costmap_service_bt_node\n    - nav2_is_stuck_condition_bt_node\n    - nav2_goal_reached_condition_bt_node\n    - nav2_goal_updated_condition_bt_node\n    - nav2_initial_pose_received_condition_bt_node\n    - nav2_reinitialize_global_localization_service_bt_node\n    - nav2_rate_controller_bt_node\n    - nav2_distance_controller_bt_node\n    - nav2_speed_controller_bt_node\n    - nav2_truncate_path_action_bt_node\n    - nav2_goal_updater_node_bt_node\n    - nav2_recovery_node_bt_node\n    - nav2_pipeline_sequence_bt_node\n    - nav2_round_robin_node_bt_node\n    - nav2_transform_available_condition_bt_node\n    - nav2_time_expired_condition_bt_node\n    - nav2_path_expiring_timer_condition\n    - nav2_distance_traveled_condition_bt_node\n    - nav2_single_trigger_bt_node\n    - nav2_is_battery_low_condition_bt_node\n    - nav2_navigate_through_poses_action_bt_node\n    - nav2_navigate_to_pose_action_bt_node\n    - nav2_remove_passed_goals_action_bt_node\n    - nav2_planner_selector_bt_node\n    - nav2_controller_selector_bt_node\n    - nav2_goal_checker_selector_bt_node\n    - nav2_controller_cancel_bt_node\n    - nav2_path_longer_on_approach_bt_node\n    - nav2_recover_nav_mesh_bt_node\n    - nav2_follow_path_cancel_bt_node\n'})}),"\n",(0,o.jsx)(e.h2,{id:"custom-plugins-for-humanoid-navigation",children:"Custom Plugins for Humanoid Navigation"}),"\n",(0,o.jsx)(e.h3,{id:"humanoid-global-planner",children:"Humanoid Global Planner"}),"\n",(0,o.jsx)(e.p,{children:"A custom global planner that considers humanoid-specific constraints:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-cpp",children:'// Example: Humanoid Global Planner header\n#include "nav2_core/global_planner.hpp"\n#include "nav2_costmap_2d/costmap_2d_ros.h"\n#include "nav2_util/lifecycle_node.hpp"\n#include "geometry_msgs/msg/pose_stamped.hpp"\n#include "nav_msgs/msg/path.h"\n\nnamespace nav2_humanoid_planner\n{\n\nclass HumanoidGlobalPlanner : public nav2_core::GlobalPlanner\n{\npublic:\n  HumanoidGlobalPlanner() = default;\n  ~HumanoidGlobalPlanner() = default;\n\n  void configure(\n    const rclcpp_lifecycle::LifecycleNode::WeakPtr & parent,\n    std::string name, std::shared_ptr<tf2_ros::Buffer> tf,\n    std::shared_ptr<nav2_costmap_2d::Costmap2DROS> costmap_ros) override;\n\n  void cleanup() override;\n  void activate() override;\n  void deactivate() override;\n\n  nav_msgs::msg::Path createPlan(\n    const geometry_msgs::msg::PoseStamped & start,\n    const geometry_msgs::msg::PoseStamped & goal) override;\n\nprivate:\n  // Humanoid-specific parameters\n  double step_length_max_;\n  double step_width_max_;\n  double min_step_clearance_;\n  bool enable_footstep_planning_;\n\n  // ZMP and balance constraints\n  double zmp_margin_;\n  double com_height_;\n\n  // Costmap for humanoid navigation\n  std::shared_ptr<nav2_costmap_2d::Costmap2DROS> costmap_ros_;\n};\n\n}  // namespace nav2_humanoid_planner\n'})}),"\n",(0,o.jsx)(e.h3,{id:"footstep-planner-integration",children:"Footstep Planner Integration"}),"\n",(0,o.jsx)(e.p,{children:"Integrating footstep planning with Nav2 for stable humanoid navigation:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'# Example: Footstep planner integration\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import PoseStamped\nfrom nav_msgs.msg import Path\nfrom builtin_interfaces.msg import Duration\nimport numpy as np\n\nclass FootstepPlanner:\n    def __init__(self):\n        self.step_length_max = 0.3  # meters\n        self.step_width_max = 0.2   # meters\n        self.step_rotation_max = 0.3  # radians\n        self.com_height = 0.8       # meters (center of mass height)\n\n    def plan_footsteps(self, path, robot_pose):\n        """\n        Convert navigation path to footstep plan for humanoid robot\n        """\n        footsteps = []\n\n        # Convert path to footstep sequence\n        for i in range(len(path.poses) - 1):\n            start_pose = path.poses[i]\n            end_pose = path.poses[i + 1]\n\n            # Calculate required steps between poses\n            step_sequence = self.calculate_step_sequence(start_pose, end_pose)\n            footsteps.extend(step_sequence)\n\n        return footsteps\n\n    def calculate_step_sequence(self, start_pose, end_pose):\n        """\n        Calculate sequence of footsteps between two poses\n        considering balance and kinematic constraints\n        """\n        # Calculate distance and direction\n        dx = end_pose.pose.position.x - start_pose.pose.position.x\n        dy = end_pose.pose.position.y - start_pose.pose.position.y\n        distance = np.sqrt(dx*dx + dy*dy)\n\n        # Calculate number of steps needed\n        num_steps = int(np.ceil(distance / self.step_length_max))\n\n        # Generate footstep sequence\n        footsteps = []\n        for i in range(num_steps):\n            ratio = (i + 1) / num_steps\n            step_x = start_pose.pose.position.x + ratio * dx\n            step_y = start_pose.pose.position.y + ratio * dy\n\n            # Create footstep pose (left or right foot alternating)\n            footstep_pose = PoseStamped()\n            footstep_pose.header.frame_id = "map"\n            footstep_pose.pose.position.x = step_x\n            footstep_pose.pose.position.y = step_y\n            footstep_pose.pose.position.z = 0.0  # Ground level\n\n            # Set orientation\n            footstep_pose.pose.orientation = start_pose.pose.orientation\n\n            footsteps.append(footstep_pose)\n\n        return footsteps\n\nclass HumanoidPathFollower(Node):\n    def __init__(self):\n        super().__init__(\'humanoid_path_follower\')\n\n        self.footstep_planner = FootstepPlanner()\n        self.path_subscriber = self.create_subscription(\n            Path, \'/plan\', self.path_callback, 10\n        )\n        self.footstep_publisher = self.create_publisher(\n            Path, \'/footstep_plan\', 10\n        )\n\n    def path_callback(self, path_msg):\n        # Get current robot pose\n        robot_pose = self.get_current_pose()\n\n        # Plan footsteps\n        footsteps = self.footstep_planner.plan_footsteps(path_msg, robot_pose)\n\n        # Publish footstep plan\n        footstep_path = Path()\n        footstep_path.header = path_msg.header\n        footstep_path.poses = footsteps\n\n        self.footstep_publisher.publish(footstep_path)\n'})}),"\n",(0,o.jsx)(e.h3,{id:"balance-controller-integration",children:"Balance Controller Integration"}),"\n",(0,o.jsx)(e.p,{children:"Implementing balance control alongside navigation:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'# Example: Balance controller for humanoid navigation\nclass BalanceController:\n    def __init__(self):\n        self.com_height = 0.8  # Center of mass height\n        self.zmp_reference = np.array([0.0, 0.0])  # Zero Moment Point reference\n        self.com_reference = np.array([0.0, 0.0, self.com_height])\n\n        # Control gains\n        self.kp_com = np.array([10.0, 10.0, 0.0])  # Proportional gains for CoM\n        self.kd_com = np.array([2.0, 2.0, 0.0])    # Derivative gains for CoM\n\n    def compute_balance_control(self, current_com, current_com_vel, dt):\n        """\n        Compute balance control based on CoM position and velocity\n        """\n        # Calculate CoM error\n        com_error = self.com_reference - current_com\n        com_vel_error = -current_com_vel  # Assuming desired velocity is 0\n\n        # Compute control forces\n        control_force = self.kp_com * com_error + self.kd_com * com_vel_error\n\n        return control_force\n\n    def update_zmp_reference(self, foot_positions):\n        """\n        Update ZMP reference based on current foot positions\n        """\n        # Calculate support polygon from foot positions\n        if len(foot_positions) == 2:  # Both feet on ground\n            # Calculate center between feet\n            zmp_ref = np.mean(foot_positions, axis=0)\n        elif len(foot_positions) == 1:  # Single foot support\n            # Use single foot position as reference\n            zmp_ref = foot_positions[0]\n        else:\n            zmp_ref = np.array([0.0, 0.0])\n\n        self.zmp_reference = zmp_ref\n'})}),"\n",(0,o.jsx)(e.h2,{id:"integration-with-isaac-sim",children:"Integration with Isaac Sim"}),"\n",(0,o.jsx)(e.h3,{id:"simulation-setup-for-humanoid-navigation",children:"Simulation Setup for Humanoid Navigation"}),"\n",(0,o.jsx)(e.p,{children:"Configuring Isaac Sim for realistic humanoid navigation testing:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'# Example: Isaac Sim setup for humanoid navigation\nimport omni\nfrom omni.isaac.kit import SimulationApp\nfrom omni.isaac.core import World\nfrom omni.isaac.core.utils.stage import add_reference_to_stage\nfrom omni.isaac.core.utils.nucleus import get_assets_root_path\nimport carb\n\nclass HumanoidNavSimulation:\n    def __init__(self):\n        # Initialize simulation\n        self.sim_app = SimulationApp({"headless": False})\n        self.world = World(stage_units_in_meters=1.0)\n\n        # Initialize ROS bridge\n        from omni.isaac.ros_bridge import _ros_bridge\n        self.ros_bridge = _ros_bridge.acquire_ros_bridge_interface()\n\n    def setup_humanoid_navigation(self):\n        """\n        Set up humanoid robot with navigation capabilities in Isaac Sim\n        """\n        # Add humanoid robot to simulation\n        asset_root = get_assets_root_path()\n        if asset_root is None:\n            carb.log_error("Could not find Isaac Sim assets. Please check your Isaac Sim installation.")\n            return False\n\n        # Load humanoid robot model\n        humanoid_path = asset_root + "/Isaac/Robots/NVIDIA/Jetbot/jetbot.usd"\n        # Note: Replace with actual humanoid robot model path\n        add_reference_to_stage(usd_path=humanoid_path, prim_path="/World/Humanoid")\n\n        # Set up navigation environment\n        self.setup_navigation_environment()\n\n        # Initialize the world\n        self.world.reset()\n\n        return True\n\n    def setup_navigation_environment(self):\n        """\n        Set up navigation testing environment\n        """\n        # Add obstacles, ramps, stairs, etc.\n        # Configure physics properties\n        # Set up sensor configurations\n        pass\n\n    def run_navigation_simulation(self):\n        """\n        Run navigation simulation with Nav2 integration\n        """\n        # Main simulation loop\n        while simulation_app.is_running():\n            self.world.step(render=True)\n\n            # Process ROS messages\n            # Update navigation commands\n            # Monitor robot state\n            pass\n\n# Usage example\ndef main():\n    nav_sim = HumanoidNavSimulation()\n\n    if nav_sim.setup_humanoid_navigation():\n        nav_sim.run_navigation_simulation()\n    else:\n        print("Failed to set up navigation simulation")\n\n    nav_sim.sim_app.close()\n'})}),"\n",(0,o.jsx)(e.h3,{id:"nav2-configuration-for-isaac-sim",children:"Nav2 Configuration for Isaac Sim"}),"\n",(0,o.jsx)(e.p,{children:"Specific configuration for Nav2 when used with Isaac Sim:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-yaml",children:'# Isaac Sim specific Nav2 parameters\nlocal_costmap:\n  local_costmap:\n    ros__parameters:\n      update_frequency: 10.0\n      publish_frequency: 10.0\n      global_frame: odom\n      robot_base_frame: base_link\n      use_sim_time: true\n      rolling_window: true\n      width: 6\n      height: 6\n      resolution: 0.05\n      robot_radius: 0.3  # Adjust for humanoid robot\n      plugins: ["voxel_layer", "inflation_layer"]\n      inflation_layer:\n        plugin: "nav2_costmap_2d::InflationLayer"\n        cost_scaling_factor: 3.0\n        inflation_radius: 0.55\n      voxel_layer:\n        plugin: "nav2_costmap_2d::VoxelLayer"\n        enabled: true\n        publish_voxel_map: true\n        origin_z: 0.0\n        z_resolution: 0.2\n        z_voxels: 10\n        max_obstacle_height: 2.0\n        mark_threshold: 0\n        observation_sources: scan\n        scan:\n          topic: /laser_scan\n          max_obstacle_height: 2.0\n          clearing: true\n          marking: true\n          data_type: "LaserScan"\n\nglobal_costmap:\n  global_costmap:\n    ros__parameters:\n      update_frequency: 1.0\n      publish_frequency: 1.0\n      global_frame: map\n      robot_base_frame: base_link\n      use_sim_time: true\n      robot_radius: 0.3  # Adjust for humanoid robot\n      resolution: 0.1\n      track_unknown_space: true\n      plugins: ["static_layer", "obstacle_layer", "inflation_layer"]\n      obstacle_layer:\n        plugin: "nav2_costmap_2d::ObstacleLayer"\n        enabled: true\n        observation_sources: scan\n        scan:\n          topic: /laser_scan\n          max_obstacle_height: 2.0\n          clearing: true\n          marking: true\n          data_type: "LaserScan"\n      static_layer:\n        plugin: "nav2_costmap_2d::StaticLayer"\n        map_subscribe_transient_local: true\n      inflation_layer:\n        plugin: "nav2_costmap_2d::InflationLayer"\n        cost_scaling_factor: 3.0\n        inflation_radius: 0.55\n'})}),"\n",(0,o.jsx)(e.h2,{id:"dynamic-obstacle-avoidance-for-humanoids",children:"Dynamic Obstacle Avoidance for Humanoids"}),"\n",(0,o.jsx)(e.h3,{id:"humanoid-specific-collision-avoidance",children:"Humanoid-Specific Collision Avoidance"}),"\n",(0,o.jsx)(e.p,{children:"Humanoid robots require special consideration for dynamic obstacle avoidance:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'# Example: Dynamic obstacle avoidance for humanoid robots\nclass HumanoidCollisionAvoidance:\n    def __init__(self):\n        self.robot_radius = 0.3  # Effective radius for humanoid\n        self.step_time = 0.5     # Time for single step\n        self.lookahead_time = 2.0  # Look ahead time for prediction\n\n    def predict_collision(self, obstacle_pos, obstacle_vel, robot_pos, robot_vel):\n        """\n        Predict potential collision between humanoid and moving obstacle\n        """\n        # Calculate relative position and velocity\n        rel_pos = obstacle_pos - robot_pos\n        rel_vel = obstacle_vel - robot_vel\n\n        # Calculate time to closest approach\n        rel_speed_sq = np.dot(rel_vel, rel_vel)\n        if rel_speed_sq < 1e-6:  # Obstacle and robot moving at same velocity\n            dist = np.linalg.norm(rel_pos)\n            return dist < (self.robot_radius + 0.2)  # Add safety margin\n\n        t_ca = -np.dot(rel_pos, rel_vel) / rel_speed_sq\n        t_ca = max(0, min(t_ca, self.lookahead_time))  # Clamp to lookahead time\n\n        # Calculate closest approach distance\n        closest_pos = rel_pos + t_ca * rel_vel\n        closest_dist = np.linalg.norm(closest_pos)\n\n        return closest_dist < (self.robot_radius + 0.2)  # Safety margin\n\n    def compute_avoidance_velocity(self, current_vel, obstacles):\n        """\n        Compute avoidance velocity to prevent collisions\n        """\n        avoidance_force = np.array([0.0, 0.0])\n\n        for obs in obstacles:\n            obs_pos = np.array([obs.position.x, obs.position.y])\n            obs_vel = np.array([obs.velocity.x, obs.velocity.y])\n            robot_pos = np.array([current_vel.x, current_vel.y])  # Simplified\n\n            # Calculate avoidance force based on distance and relative velocity\n            to_robot = robot_pos - obs_pos\n            dist = np.linalg.norm(to_robot)\n\n            if dist < 2.0:  # Influence radius\n                # Repulsive force\n                force_mag = (2.0 - dist) / 2.0  # Decreases with distance\n                force_dir = to_robot / dist if dist > 0.001 else np.array([1.0, 0.0])\n                avoidance_force += force_mag * force_dir\n\n        # Limit force magnitude\n        force_norm = np.linalg.norm(avoidance_force)\n        if force_norm > 1.0:\n            avoidance_force = avoidance_force / force_norm\n\n        return avoidance_force\n'})}),"\n",(0,o.jsx)(e.h3,{id:"multi-terrain-navigation",children:"Multi-Terrain Navigation"}),"\n",(0,o.jsx)(e.p,{children:"Handling different terrain types for humanoid navigation:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"# Example: Multi-terrain navigation considerations\nclass MultiTerrainNavigator:\n    def __init__(self):\n        self.terrain_types = {\n            'flat': {'max_slope': 0.1, 'step_height': 0.05, 'traction': 1.0},\n            'grass': {'max_slope': 0.2, 'step_height': 0.05, 'traction': 0.8},\n            'stairs': {'max_slope': 0.8, 'step_height': 0.18, 'traction': 0.9},\n            'ramp': {'max_slope': 0.3, 'step_height': 0.05, 'traction': 0.7},\n            'rough': {'max_slope': 0.15, 'step_height': 0.08, 'traction': 0.6}\n        }\n\n    def evaluate_terrain_traversability(self, terrain_map, robot_pose):\n        \"\"\"\n        Evaluate terrain traversability for humanoid robot\n        \"\"\"\n        traversability_scores = {}\n\n        for terrain_type, properties in self.terrain_types.items():\n            # Calculate traversability based on terrain properties\n            slope_penalty = min(1.0, abs(properties['max_slope']) / 0.5)\n            step_penalty = min(1.0, properties['step_height'] / 0.2)\n            traction_score = properties['traction']\n\n            # Combine penalties into traversability score\n            traversability = traction_score * (1 - slope_penalty) * (1 - step_penalty)\n            traversability_scores[terrain_type] = traversability\n\n        return traversability_scores\n\n    def adjust_navigation_for_terrain(self, current_terrain, base_velocity):\n        \"\"\"\n        Adjust navigation parameters based on current terrain\n        \"\"\"\n        terrain_props = self.terrain_types.get(current_terrain, self.terrain_types['flat'])\n\n        # Adjust velocity based on terrain\n        adjusted_velocity = base_velocity * terrain_props['traction']\n\n        # Adjust step parameters\n        step_params = {\n            'max_step_length': min(0.3, 0.3 * terrain_props['traction']),\n            'max_step_width': min(0.2, 0.2 * terrain_props['traction']),\n            'step_height_tolerance': terrain_props['step_height']\n        }\n\n        return adjusted_velocity, step_params\n"})}),"\n",(0,o.jsx)(e.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,o.jsx)(e.h3,{id:"real-time-navigation-considerations",children:"Real-time Navigation Considerations"}),"\n",(0,o.jsx)(e.p,{children:"Optimizing Nav2 for real-time humanoid navigation:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-bash",children:"# Example: Optimized launch parameters for real-time operation\n# launch_realtime_nav2.py\nimport launch\nfrom launch import LaunchDescription\nfrom launch_ros.actions import Node\nfrom launch.actions import DeclareLaunchArgument\nfrom launch.substitutions import LaunchConfiguration\nfrom ament_index_python.packages import get_package_share_directory\nimport os\n\ndef generate_launch_description():\n    # Real-time optimized parameters\n    use_sim_time = LaunchConfiguration('use_sim_time', default='true')\n\n    nav2_params = os.path.join(\n        get_package_share_directory('nav2_humanoid_bringup'),\n        'params',\n        'nav2_realtime_params.yaml'\n    )\n\n    # Navigation nodes with real-time priority\n    lifecycle_nodes = ['controller_server',\n                       'planner_server',\n                       'recoverer_server',\n                       'bt_navigator',\n                       'waypoint_follower']\n\n    return LaunchDescription([\n        # Real-time optimized controller server\n        Node(\n            package='nav2_controller',\n            executable='controller_server',\n            output='screen',\n            parameters=[nav2_params, {'use_sim_time': use_sim_time}],\n            arguments=['--ros-args', '--priority', '80']  # Real-time priority\n        ),\n\n        # Lifecycle manager\n        Node(\n            package='nav2_lifecycle_manager',\n            executable='lifecycle_manager',\n            name='lifecycle_manager_navigation',\n            output='screen',\n            parameters=[{'use_sim_time': use_sim_time},\n                        {'autostart': True},\n                        {'node_names': lifecycle_nodes}]\n        )\n    ])\n"})}),"\n",(0,o.jsx)(e.h3,{id:"memory-and-computation-optimization",children:"Memory and Computation Optimization"}),"\n",(0,o.jsx)(e.p,{children:"Efficient resource usage for humanoid navigation:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Path Caching"}),": Cache computed paths for similar destinations"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Incremental Updates"}),": Update maps incrementally rather than full recalculation"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Multi-resolution Maps"}),": Use different map resolutions for different planning needs"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Predictive Planning"}),": Pre-compute likely navigation paths"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"practical-examples",children:"Practical Examples"}),"\n",(0,o.jsx)(e.h3,{id:"example-1-simple-humanoid-navigation",children:"Example 1: Simple Humanoid Navigation"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"# Example: Simple humanoid navigation with Nav2\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import PoseStamped\nfrom nav2_msgs.action import NavigateToPose\nfrom rclpy.action import ActionClient\nimport time\n\nclass HumanoidNavigator(Node):\n    def __init__(self):\n        super().__init__('humanoid_navigator')\n\n        # Action client for navigation\n        self.nav_client = ActionClient(self, NavigateToPose, 'navigate_to_pose')\n\n        # Wait for Nav2 to be available\n        self.nav_client.wait_for_server()\n\n    def navigate_to_pose(self, x, y, theta):\n        \"\"\"\n        Navigate humanoid robot to specified pose\n        \"\"\"\n        goal_msg = NavigateToPose.Goal()\n        goal_msg.pose.header.frame_id = 'map'\n        goal_msg.pose.header.stamp = self.get_clock().now().to_msg()\n\n        # Set target position\n        goal_msg.pose.pose.position.x = x\n        goal_msg.pose.pose.position.y = y\n        goal_msg.pose.pose.position.z = 0.0\n\n        # Convert theta to quaternion\n        import math\n        goal_msg.pose.pose.orientation.z = math.sin(theta / 2.0)\n        goal_msg.pose.pose.orientation.w = math.cos(theta / 2.0)\n\n        # Send navigation goal\n        self.get_logger().info(f'Navigating to position: ({x}, {y}, {theta})')\n\n        future = self.nav_client.send_goal_async(goal_msg)\n        return future\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    navigator = HumanoidNavigator()\n\n    # Example navigation to a specific location\n    future = navigator.navigate_to_pose(5.0, 3.0, 0.0)\n\n    # Wait for completion\n    rclpy.spin_until_future_complete(navigator, future)\n\n    result = future.result()\n    if result:\n        navigator.get_logger().info('Navigation completed successfully')\n    else:\n        navigator.get_logger().error('Navigation failed')\n\n    navigator.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,o.jsx)(e.h3,{id:"example-2-complex-navigation-with-obstacle-avoidance",children:"Example 2: Complex Navigation with Obstacle Avoidance"}),"\n",(0,o.jsx)(e.p,{children:"Implementing navigation with dynamic obstacle avoidance and multi-terrain handling."}),"\n",(0,o.jsx)(e.h2,{id:"troubleshooting-and-validation",children:"Troubleshooting and Validation"}),"\n",(0,o.jsx)(e.h3,{id:"common-navigation-issues",children:"Common Navigation Issues"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Path Planning Failures"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Check costmap configuration"}),"\n",(0,o.jsx)(e.li,{children:"Verify robot footprint settings"}),"\n",(0,o.jsx)(e.li,{children:"Ensure proper map resolution"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Balance Issues During Navigation"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Adjust step timing parameters"}),"\n",(0,o.jsx)(e.li,{children:"Verify CoM height estimation"}),"\n",(0,o.jsx)(e.li,{children:"Check footstep planning accuracy"}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsx)(e.p,{children:(0,o.jsx)(e.strong,{children:"Dynamic Obstacle Collisions"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Increase safety margins"}),"\n",(0,o.jsx)(e.li,{children:"Improve obstacle detection"}),"\n",(0,o.jsx)(e.li,{children:"Adjust prediction horizons"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"validation-methods",children:"Validation Methods"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"# Example: Navigation validation functions\ndef validate_navigation_performance(nav_results):\n    \"\"\"\n    Validate navigation performance metrics\n    \"\"\"\n    metrics = {\n        'success_rate': 0.0,\n        'avg_time': 0.0,\n        'avg_path_efficiency': 0.0,\n        'safety_compliance': 0.0\n    }\n\n    successful_navigations = [r for r in nav_results if r.success]\n    if successful_navigations:\n        metrics['success_rate'] = len(successful_navigations) / len(nav_results)\n        metrics['avg_time'] = sum(r.time for r in successful_navigations) / len(successful_navigations)\n\n        # Calculate path efficiency (optimal path length / actual path length)\n        path_efficiencies = [r.optimal_length / r.actual_length for r in successful_navigations if r.actual_length > 0]\n        if path_efficiencies:\n            metrics['avg_path_efficiency'] = sum(path_efficiencies) / len(path_efficiencies)\n\n    # Safety compliance (percentage of navigations without collisions)\n    safe_navigations = [r for r in nav_results if not r.collision]\n    if nav_results:\n        metrics['safety_compliance'] = len(safe_navigations) / len(nav_results)\n\n    return metrics\n"})}),"\n",(0,o.jsx)(e.h2,{id:"exercises",children:"Exercises"}),"\n",(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Nav2 Configuration"}),": Configure Nav2 for a specific humanoid robot model with appropriate parameters"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Footstep Planning"}),": Implement a basic footstep planner that works with Nav2's path planning"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Simulation Testing"}),": Test navigation in Isaac Sim with various obstacle configurations"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Performance Analysis"}),": Compare navigation performance with and without humanoid-specific modifications"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(e.p,{children:"This chapter has covered Nav2 path planning specifically adapted for humanoid robots, including custom plugins, footstep planning integration, and balance considerations. You've learned how to configure Nav2 for the unique challenges of bipedal locomotion and integrate it with Isaac Sim for realistic testing."}),"\n",(0,o.jsx)(e.h2,{id:"next-steps",children:"Next Steps"}),"\n",(0,o.jsx)(e.p,{children:"The Isaac AI Brain module is now complete! You have learned about Isaac Sim for photorealistic simulation, Isaac ROS for hardware-accelerated VSLAM, and Nav2 for humanoid path planning. These technologies together form a powerful platform for developing advanced humanoid robotics applications."})]})}function p(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(d,{...n})}):d(n)}}}]);