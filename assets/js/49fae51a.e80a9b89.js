"use strict";(globalThis.webpackChunkai_spec_driven_book_with_rag_chatbot_frontend=globalThis.webpackChunkai_spec_driven_book_with_rag_chatbot_frontend||[]).push([[981],{886(n,e,i){i.r(e),i.d(e,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"digital-twin/physics-simulation-gazebo","title":"Physics Simulation with Gazebo","description":"Introduction to Gazebo Physics Simulation for Humanoid Robots","source":"@site/docs/digital-twin/physics-simulation-gazebo.md","sourceDirName":"digital-twin","slug":"/digital-twin/physics-simulation-gazebo","permalink":"/docs/digital-twin/physics-simulation-gazebo","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/digital-twin/physics-simulation-gazebo.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1,"title":"Physics Simulation with Gazebo"},"sidebar":"tutorialSidebar","previous":{"title":"Robot Structure with URDF","permalink":"/docs/ros2-humanoid/robot-structure-urdf"},"next":{"title":"Digital Twins & HRI in Unity","permalink":"/docs/digital-twin/digital-twins-hri-unity"}}');var t=i(4848),s=i(8453);const r={sidebar_position:1,title:"Physics Simulation with Gazebo"},l="Physics Simulation with Gazebo",a={},c=[{value:"Introduction to Gazebo Physics Simulation for Humanoid Robots",id:"introduction-to-gazebo-physics-simulation-for-humanoid-robots",level:2},{value:"Why Gazebo Matters for Humanoid Robotics",id:"why-gazebo-matters-for-humanoid-robotics",level:3},{value:"Learning Objectives",id:"learning-objectives",level:3},{value:"Prerequisites",id:"prerequisites",level:3},{value:"Gazebo&#39;s Physics Engines",id:"gazebos-physics-engines",level:2},{value:"ODE (Open Dynamics Engine)",id:"ode-open-dynamics-engine",level:3},{value:"Bullet Physics",id:"bullet-physics",level:3},{value:"Simbody",id:"simbody",level:3},{value:"Choosing the Right Physics Engine for Humanoid Robots",id:"choosing-the-right-physics-engine-for-humanoid-robots",level:3},{value:"Configuration Example for Physics Engine Selection",id:"configuration-example-for-physics-engine-selection",level:4},{value:"URDF Integration with Gazebo",id:"urdf-integration-with-gazebo",level:2},{value:"Complete Humanoid Robot URDF Example",id:"complete-humanoid-robot-urdf-example",level:3},{value:"Gazebo-Specific URDF Tags",id:"gazebo-specific-urdf-tags",level:3},{value:"Physics Parameters for Humanoid Robots",id:"physics-parameters-for-humanoid-robots",level:3},{value:"Joint Constraints and Motor Controls",id:"joint-constraints-and-motor-controls",level:2},{value:"Joint Types in Gazebo for Humanoid Robots",id:"joint-types-in-gazebo-for-humanoid-robots",level:3},{value:"Joint Parameters for Humanoid Robots",id:"joint-parameters-for-humanoid-robots",level:3},{value:"Advanced Motor Control Implementation",id:"advanced-motor-control-implementation",level:3},{value:"Joint Control Strategies for Humanoid Robots",id:"joint-control-strategies-for-humanoid-robots",level:3},{value:"Example Controller Configuration",id:"example-controller-configuration",level:3},{value:"Collision Detection and Response",id:"collision-detection-and-response",level:2},{value:"Collision Properties for Humanoid Robots",id:"collision-properties-for-humanoid-robots",level:3},{value:"Surface Properties for Realistic Contact",id:"surface-properties-for-realistic-contact",level:3},{value:"Contact Sensors for Feedback",id:"contact-sensors-for-feedback",level:3},{value:"Physics Parameters for Humanoid Balance",id:"physics-parameters-for-humanoid-balance",level:3},{value:"Tuning for Humanoid Applications",id:"tuning-for-humanoid-applications",level:3},{value:"Example: Complete Foot Configuration",id:"example-complete-foot-configuration",level:3},{value:"Exercises",id:"exercises",level:2},{value:"Exercise 1: Basic Humanoid Robot Model",id:"exercise-1-basic-humanoid-robot-model",level:3},{value:"Exercise 2: Physics Parameter Tuning",id:"exercise-2-physics-parameter-tuning",level:3},{value:"Exercise 3: Collision Detection and Response",id:"exercise-3-collision-detection-and-response",level:3},{value:"Exercise 4: Advanced Joint Control",id:"exercise-4-advanced-joint-control",level:3},{value:"Summary",id:"summary",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"physics-simulation-with-gazebo",children:"Physics Simulation with Gazebo"})}),"\n",(0,t.jsx)(e.h2,{id:"introduction-to-gazebo-physics-simulation-for-humanoid-robots",children:"Introduction to Gazebo Physics Simulation for Humanoid Robots"}),"\n",(0,t.jsx)(e.p,{children:"This chapter covers the fundamentals of physics simulation using Gazebo for humanoid robotics applications. Gazebo is a powerful robotics simulation environment that provides accurate physics simulation, realistic rendering, and convenient programmatic interfaces."}),"\n",(0,t.jsx)(e.h3,{id:"why-gazebo-matters-for-humanoid-robotics",children:"Why Gazebo Matters for Humanoid Robotics"}),"\n",(0,t.jsx)(e.p,{children:"Gazebo is essential for humanoid robotics development because it provides:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Realistic Physics Simulation"}),": Accurate modeling of forces, collisions, and dynamics that humanoid robots experience"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Safe Testing Environment"}),": Test complex behaviors without risk of damaging expensive hardware"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Rapid Prototyping"}),": Quickly iterate on robot designs and control algorithms"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Cost-Effective Development"}),": Reduce the need for physical prototypes during early development phases"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Reproducible Experiments"}),": Consistent testing conditions that can be replicated across teams"]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"The physics simulation capabilities in Gazebo are particularly important for humanoid robots, which have complex multi-link structures with many degrees of freedom that must interact with the environment in sophisticated ways."}),"\n",(0,t.jsx)(e.h3,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Understand the core concepts of Gazebo physics simulation"}),"\n",(0,t.jsx)(e.li,{children:"Learn about different physics engines available in Gazebo (ODE, Bullet, Simbody)"}),"\n",(0,t.jsx)(e.li,{children:"Master URDF integration with Gazebo for humanoid robot models"}),"\n",(0,t.jsx)(e.li,{children:"Configure joint constraints and motor controls"}),"\n",(0,t.jsx)(e.li,{children:"Implement collision detection and response mechanisms"}),"\n",(0,t.jsx)(e.li,{children:"Apply best practices for physics parameter tuning for humanoid robots"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"prerequisites",children:"Prerequisites"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Basic understanding of robotics concepts (kinematics, dynamics)"}),"\n",(0,t.jsx)(e.li,{children:"Familiarity with ROS/ROS2 (recommended but not required)"}),"\n",(0,t.jsx)(e.li,{children:"Basic programming skills in Python or C++"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"gazebos-physics-engines",children:"Gazebo's Physics Engines"}),"\n",(0,t.jsx)(e.p,{children:"Gazebo supports multiple physics engines that provide different capabilities for simulation, each with specific strengths for humanoid robotics applications:"}),"\n",(0,t.jsx)(e.h3,{id:"ode-open-dynamics-engine",children:"ODE (Open Dynamics Engine)"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Default physics engine in many Gazebo versions"}),"\n",(0,t.jsx)(e.li,{children:"Good performance for most robotics applications"}),"\n",(0,t.jsx)(e.li,{children:"Supports rigid body dynamics and basic collision detection"}),"\n",(0,t.jsx)(e.li,{children:"Well-tested and stable for humanoid robot simulations"}),"\n",(0,t.jsx)(e.li,{children:"Optimal for real-time applications with moderate accuracy requirements"}),"\n",(0,t.jsx)(e.li,{children:"Best suited for: Walking algorithms, basic manipulation, environment interaction"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"bullet-physics",children:"Bullet Physics"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"High-performance physics engine"}),"\n",(0,t.jsx)(e.li,{children:"Excellent for complex collision detection"}),"\n",(0,t.jsx)(e.li,{children:"Good support for constraints and joints"}),"\n",(0,t.jsx)(e.li,{children:"Faster than ODE for complex scenarios"}),"\n",(0,t.jsx)(e.li,{children:"Better handling of complex contact situations"}),"\n",(0,t.jsx)(e.li,{children:"Best suited for: High-fidelity contact simulation, complex environments, multi-robot scenarios"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"simbody",children:"Simbody"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Multibody dynamics engine"}),"\n",(0,t.jsx)(e.li,{children:"High-fidelity simulation capabilities"}),"\n",(0,t.jsx)(e.li,{children:"Particularly good for biomechanical simulations"}),"\n",(0,t.jsx)(e.li,{children:"More accurate for complex articulated systems"}),"\n",(0,t.jsx)(e.li,{children:"Better energy conservation properties"}),"\n",(0,t.jsx)(e.li,{children:"Best suited for: Biomechanically-inspired robots, high-precision applications, research scenarios"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"choosing-the-right-physics-engine-for-humanoid-robots",children:"Choosing the Right Physics Engine for Humanoid Robots"}),"\n",(0,t.jsx)(e.p,{children:"The choice of physics engine depends on your specific humanoid robot requirements:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"For real-time control"}),": ODE or Bullet provide good balance of performance and accuracy"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"For high-fidelity simulation"}),": Simbody offers superior accuracy for complex dynamics"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"For complex contacts"}),": Bullet handles multiple contact points better than ODE"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"For stability"}),": ODE has proven stability in long-running simulations"]}),"\n"]}),"\n",(0,t.jsx)(e.h4,{id:"configuration-example-for-physics-engine-selection",children:"Configuration Example for Physics Engine Selection"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'\x3c!-- In your world file --\x3e\n<sdf version="1.6">\n  <world name="humanoid_world">\n    \x3c!-- Choose physics engine --\x3e\n    <physics type="ode">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n      <real_time_update_rate>1000</real_time_update_rate>\n      <gravity>0 0 -9.8</gravity>\n    </physics>\n\n    \x3c!-- Alternative: Using Bullet --\x3e\n    \x3c!--\n    <physics type="bullet">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1.0</real_time_factor>\n      <real_time_update_rate>1000</real_time_update_rate>\n      <gravity>0 0 -9.8</gravity>\n    </physics>\n    --\x3e\n  </world>\n</sdf>\n'})}),"\n",(0,t.jsx)(e.h2,{id:"urdf-integration-with-gazebo",children:"URDF Integration with Gazebo"}),"\n",(0,t.jsx)(e.p,{children:"The Unified Robot Description Format (URDF) is the standard format for describing robots in ROS. Integrating URDF with Gazebo requires specific tags and configurations that define how the robot behaves in the simulation environment."}),"\n",(0,t.jsx)(e.h3,{id:"complete-humanoid-robot-urdf-example",children:"Complete Humanoid Robot URDF Example"}),"\n",(0,t.jsx)(e.p,{children:"Here's a more comprehensive example of a humanoid robot URDF that includes proper physics properties for Gazebo simulation:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\n<robot name="simple_humanoid">\n  \x3c!-- Base/Pelvis Link --\x3e\n  <link name="base_link">\n    <visual>\n      <geometry>\n        <box size="0.2 0.15 0.3"/>\n      </geometry>\n      <material name="light_grey">\n        <color rgba="0.7 0.7 0.7 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.2 0.15 0.3"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="10.0"/>\n      <origin xyz="0 0 0"/>\n      <inertia ixx="0.1" ixy="0.0" ixz="0.0" iyy="0.1" iyz="0.0" izz="0.1"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Torso --\x3e\n  <link name="torso">\n    <visual>\n      <geometry>\n        <box size="0.2 0.15 0.4"/>\n      </geometry>\n      <material name="light_grey"/>\n    </visual>\n    <collision>\n      <geometry>\n        <box size="0.2 0.15 0.4"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="8.0"/>\n      <origin xyz="0 0 0.2"/>\n      <inertia ixx="0.2" ixy="0.0" ixz="0.0" iyy="0.2" iyz="0.0" izz="0.1"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Head --\x3e\n  <link name="head">\n    <visual>\n      <geometry>\n        <sphere radius="0.1"/>\n      </geometry>\n      <material name="white">\n        <color rgba="1.0 1.0 1.0 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <sphere radius="0.1"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="2.0"/>\n      <inertia ixx="0.004" ixy="0.0" ixz="0.0" iyy="0.004" iyz="0.0" izz="0.004"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Left Arm Links --\x3e\n  <link name="left_upper_arm">\n    <visual>\n      <geometry>\n        <cylinder length="0.3" radius="0.05"/>\n      </geometry>\n      <material name="blue">\n        <color rgba="0.0 0.0 1.0 1.0"/>\n      </material>\n    </visual>\n    <collision>\n      <geometry>\n        <cylinder length="0.3" radius="0.05"/>\n      </geometry>\n    </collision>\n    <inertial>\n      <mass value="1.5"/>\n      <inertia ixx="0.005" ixy="0.0" ixz="0.0" iyy="0.005" iyz="0.0" izz="0.001"/>\n    </inertial>\n  </link>\n\n  \x3c!-- Joints connecting the links --\x3e\n  <joint name="torso_joint" type="fixed">\n    <parent link="base_link"/>\n    <child link="torso"/>\n    <origin xyz="0 0 0.3"/>\n  </joint>\n\n  <joint name="head_joint" type="revolute">\n    <parent link="torso"/>\n    <child link="head"/>\n    <origin xyz="0 0 0.4"/>\n    <axis xyz="0 1 0"/>\n    <limit lower="-0.5" upper="0.5" effort="100" velocity="1"/>\n    <dynamics damping="0.5" friction="0.1"/>\n  </joint>\n\n  <joint name="left_shoulder_joint" type="revolute">\n    <parent link="torso"/>\n    <child link="left_upper_arm"/>\n    <origin xyz="0.15 0 0.2" rpy="0 0 1.5708"/>\n    <axis xyz="1 0 0"/>\n    <limit lower="-1.57" upper="1.57" effort="50" velocity="1"/>\n    <dynamics damping="0.3" friction="0.05"/>\n  </joint>\n\n  \x3c!-- Gazebo-specific tags --\x3e\n  <gazebo reference="base_link">\n    <material>Gazebo/Grey</material>\n  </gazebo>\n\n  <gazebo reference="torso">\n    <material>Gazebo/Grey</material>\n  </gazebo>\n\n  <gazebo reference="head">\n    <material>Gazebo/White</material>\n  </gazebo>\n\n  <gazebo reference="left_upper_arm">\n    <material>Gazebo/Blue</material>\n  </gazebo>\n\n  \x3c!-- Gazebo plugins for ROS control --\x3e\n  <gazebo>\n    <plugin name="gazebo_ros_control" filename="libgazebo_ros_control.so">\n      <robotNamespace>/simple_humanoid</robotNamespace>\n      <robotSimType>gazebo_ros_control/DefaultRobotHWSim</robotSimType>\n    </plugin>\n  </gazebo>\n</robot>\n'})}),"\n",(0,t.jsx)(e.h3,{id:"gazebo-specific-urdf-tags",children:"Gazebo-Specific URDF Tags"}),"\n",(0,t.jsxs)(e.p,{children:["The ",(0,t.jsx)(e.code,{children:"<gazebo>"})," tags in URDF allow you to specify simulation-specific properties:"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.code,{children:"<material>"})}),": Defines visual appearance in Gazebo"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.code,{children:"<damping>"})}),": Controls motion damping for more realistic behavior"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsxs)(e.strong,{children:[(0,t.jsx)(e.code,{children:"<mu1>"}),", ",(0,t.jsx)(e.code,{children:"<mu2>"})]}),": Friction coefficients for contact simulation"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsxs)(e.strong,{children:[(0,t.jsx)(e.code,{children:"<kp>"}),", ",(0,t.jsx)(e.code,{children:"<kd>"})]}),": Contact stiffness and damping parameters"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.code,{children:"<maxVel>"})}),", ",(0,t.jsx)(e.code,{children:"<minDepth>"}),"**: Contact constraint parameters"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"physics-parameters-for-humanoid-robots",children:"Physics Parameters for Humanoid Robots"}),"\n",(0,t.jsx)(e.p,{children:"Proper physics parameters are crucial for stable humanoid simulation:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Mass values"}),": Should reflect realistic robot weights"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Inertia tensors"}),": Should be physically plausible for the link shapes"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Damping values"}),": Help stabilize joint movements"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Friction coefficients"}),": Affect ground contact and manipulation"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Joint limits"}),": Prevent damage and ensure realistic motion ranges"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"joint-constraints-and-motor-controls",children:"Joint Constraints and Motor Controls"}),"\n",(0,t.jsx)(e.h3,{id:"joint-types-in-gazebo-for-humanoid-robots",children:"Joint Types in Gazebo for Humanoid Robots"}),"\n",(0,t.jsx)(e.p,{children:"Gazebo supports several joint types that are essential for humanoid robot simulation. Each joint type serves specific purposes in mimicking human-like movement:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Fixed joints"}),": Rigid connections between links (e.g., attaching sensors to the robot body)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Revolute joints"}),": Rotational joints with limited range (e.g., elbow, knee joints)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Continuous joints"}),": Rotational joints without limits (e.g., shoulder, hip joints with full rotation)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Prismatic joints"}),": Linear sliding joints (rarely used in humanoid robots)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Floating joints"}),": 6-DOF unconstrained joints (used for floating base simulation)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Planar joints"}),": Motion constrained to a plane (rarely used in humanoid robots)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Spherical joints"}),": Ball-and-socket joints with 3-DOF rotation (useful for shoulder/hip joints)"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"joint-parameters-for-humanoid-robots",children:"Joint Parameters for Humanoid Robots"}),"\n",(0,t.jsx)(e.p,{children:"Proper joint configuration is critical for realistic humanoid movement:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.code,{children:"<limit>"})}),": Defines joint limits, effort, and velocity constraints"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.code,{children:"<dynamics>"})}),": Sets damping and friction parameters"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.code,{children:"<safety_controller>"})}),": Provides safety limits to prevent damage"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.code,{children:"<calibration>"})}),": Defines joint zero position"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:(0,t.jsx)(e.code,{children:"<mimic>"})}),": Creates coupled joint relationships"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"advanced-motor-control-implementation",children:"Advanced Motor Control Implementation"}),"\n",(0,t.jsx)(e.p,{children:"For sophisticated humanoid control, you'll need to implement proper ROS control interfaces:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Joint definitions with proper control parameters --\x3e\n<joint name="left_hip_yaw_joint" type="revolute">\n  <parent link="base_link"/>\n  <child link="left_thigh"/>\n  <origin xyz="0 0.1 -0.1" rpy="0 0 0"/>\n  <axis xyz="0 0 1"/>\n  <limit lower="-1.0" upper="1.0" effort="200" velocity="5"/>\n  <dynamics damping="1.0" friction="0.1"/>\n  <safety_controller k_position="20" k_velocity="400" soft_lower_limit="-0.9" soft_upper_limit="0.9"/>\n</joint>\n\n<joint name="left_hip_roll_joint" type="revolute">\n  <parent link="left_thigh"/>\n  <child link="left_shin"/>\n  <origin xyz="0 0 -0.5" rpy="0 0 0"/>\n  <axis xyz="1 0 0"/>\n  <limit lower="-0.5" upper="1.5" effort="200" velocity="5"/>\n  <dynamics damping="1.0" friction="0.1"/>\n</joint>\n\n\x3c!-- Transmission for ROS control --\x3e\n<transmission name="left_hip_yaw_trans">\n  <type>transmission_interface/SimpleTransmission</type>\n  <joint name="left_hip_yaw_joint">\n    <hardwareInterface>hardware_interface/PositionJointInterface</hardwareInterface>\n  </joint>\n  <actuator name="left_hip_yaw_motor">\n    <hardwareInterface>hardware_interface/PositionJointInterface</hardwareInterface>\n    <mechanicalReduction>1</mechanicalReduction>\n  </actuator>\n</transmission>\n\n\x3c!-- Gazebo plugin for ROS control --\x3e\n<gazebo>\n  <plugin name="gazebo_ros_control" filename="libgazebo_ros_control.so">\n    <robotNamespace>/simple_humanoid</robotNamespace>\n    <robotSimType>gazebo_ros_control/DefaultRobotHWSim</robotSimType>\n    <legacyModeNS>true</legacyModeNS>\n  </plugin>\n</gazebo>\n'})}),"\n",(0,t.jsx)(e.h3,{id:"joint-control-strategies-for-humanoid-robots",children:"Joint Control Strategies for Humanoid Robots"}),"\n",(0,t.jsx)(e.p,{children:"Different control strategies work best for different aspects of humanoid locomotion:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Position Control"}),": Good for precise pose following, commonly used for manipulation"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Velocity Control"}),": Useful for smooth motion, good for walking patterns"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Effort Control"}),": Provides direct force control, essential for compliant behaviors"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Impedance Control"}),": Allows for variable stiffness, important for safe human interaction"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"example-controller-configuration",children:"Example Controller Configuration"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-yaml",children:"# Controllers configuration file (controllers.yaml)\njoint_state_controller:\n  type: joint_state_controller/JointStateController\n  publish_rate: 50\n\n# Position controllers for each joint\nleft_hip_yaw_position_controller:\n  type: position_controllers/JointPositionController\n  joint: left_hip_yaw_joint\n  pid: {p: 100.0, i: 0.01, d: 10.0}\n\nleft_hip_roll_position_controller:\n  type: position_controllers/JointPositionController\n  joint: left_hip_roll_joint\n  pid: {p: 100.0, i: 0.01, d: 10.0}\n\n# Effort controllers for compliance\nleft_ankle_effort_controller:\n  type: effort_controllers/JointEffortController\n  joint: left_ankle_joint\n  pid: {p: 10.0, i: 0.1, d: 0.5}\n"})}),"\n",(0,t.jsx)(e.h2,{id:"collision-detection-and-response",children:"Collision Detection and Response"}),"\n",(0,t.jsx)(e.h3,{id:"collision-properties-for-humanoid-robots",children:"Collision Properties for Humanoid Robots"}),"\n",(0,t.jsx)(e.p,{children:"Gazebo provides sophisticated collision detection and response mechanisms that are crucial for humanoid robot simulation, especially for tasks like walking, balance, and manipulation:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Contact sensors"}),": Detect when robot parts touch the environment or self-collide"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Collision checking"}),": Determine if robot links intersect with environment objects"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Response physics"}),": Calculate contact forces and reactions for realistic interaction"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Ground contact"}),": Essential for stable walking and balance simulation"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Self-collision avoidance"}),": Prevents robot from intersecting with itself"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"surface-properties-for-realistic-contact",children:"Surface Properties for Realistic Contact"}),"\n",(0,t.jsx)(e.p,{children:"For humanoid robots, proper surface properties are essential for realistic ground contact and manipulation:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'<gazebo reference="left_foot_link">\n  <collision name="left_foot_collision">\n    <surface>\n      <contact>\n        <ode>\n          \x3c!-- Constraint Force Mixing (CFM) - affects constraint compliance --\x3e\n          <soft_cfm>0.001</soft_cfm>\n          \x3c!-- Error Reduction Parameter (ERP) - affects constraint stiffness --\x3e\n          <soft_erp>0.9</soft_erp>\n          <kp>1e8</kp>  \x3c!-- Spring stiffness --\x3e\n          <kd>1e4</kd>  \x3c!-- Damping coefficient --\x3e\n          <max_vel>100.0</max_vel>  \x3c!-- Maximum contact correction velocity --\x3e\n          <min_depth>0.001</min_depth>  \x3c!-- Penetration depth before contact force applied --\x3e\n        </ode>\n      </contact>\n      <friction>\n        <ode>\n          <mu>0.8</mu>  \x3c!-- Primary friction coefficient --\x3e\n          <mu2>0.8</mu2>  \x3c!-- Secondary friction coefficient --\x3e\n          <fdir1>0 0 0</fdir1>  \x3c!-- Friction direction --\x3e\n          <slip1>0.0</slip1>  \x3c!-- Primary slip coefficient --\x3e\n          <slip2>0.0</slip2>  \x3c!-- Secondary slip coefficient --\x3e\n        </ode>\n      </friction>\n      <bounce>\n        <restitution_coefficient>0.01</restitution_coefficient>  \x3c!-- Bounciness --\x3e\n        <threshold>10.0</threshold>  \x3c!-- Velocity threshold for bounce --\x3e\n      </bounce>\n    </surface>\n  </collision>\n</gazebo>\n'})}),"\n",(0,t.jsx)(e.h3,{id:"contact-sensors-for-feedback",children:"Contact Sensors for Feedback"}),"\n",(0,t.jsx)(e.p,{children:"Contact sensors provide crucial feedback for humanoid robot control:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'<gazebo reference="left_foot_link">\n  <sensor name="left_foot_contact" type="contact">\n    <always_on>true</always_on>\n    <update_rate>100</update_rate>\n    <contact>\n      <collision>left_foot_collision</collision>\n    </contact>\n    <plugin name="left_foot_contact_plugin" filename="libgazebo_ros_bumper.so">\n      <alwaysOn>true</alwaysOn>\n      <frameName>left_foot_link</frameName>\n      <topicName>left_foot_bumper</topicName>\n      <bumperTopicName>left_foot_contact_states</bumperTopicName>\n    </plugin>\n  </sensor>\n</gazebo>\n'})}),"\n",(0,t.jsx)(e.h3,{id:"physics-parameters-for-humanoid-balance",children:"Physics Parameters for Humanoid Balance"}),"\n",(0,t.jsx)(e.p,{children:"Proper physics parameters are essential for stable humanoid simulation:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"CFM (Constraint Force Mixing)"}),": Lower values = stiffer constraints, but potentially unstable"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"ERP (Error Reduction Parameter)"}),": Higher values = faster error correction, but potentially oscillatory"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"kp/kd"}),": Spring stiffness and damping for contact response"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Friction coefficients"}),": Affect grip and stability during walking"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Contact depth"}),": Affects how much penetration is allowed before forces are applied"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"tuning-for-humanoid-applications",children:"Tuning for Humanoid Applications"}),"\n",(0,t.jsx)(e.p,{children:"For humanoid robots, consider these tuning guidelines:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Walking stability"}),": Use higher ERP (0.8-0.95) and moderate CFM (0.0001-0.001)"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Manipulation"}),": Use higher stiffness (kp = 1e8) for precise contact"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Balance"}),": Adjust friction coefficients (0.7-1.0) for realistic ground contact"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Performance"}),": Lower update rates (50-100Hz) for faster simulation, higher rates (500-1000Hz) for accuracy"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"example-complete-foot-configuration",children:"Example: Complete Foot Configuration"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Complete foot configuration optimized for humanoid walking --\x3e\n<link name="left_foot">\n  <visual>\n    <geometry>\n      <box size="0.2 0.1 0.05"/>\n    </geometry>\n    <material name="black">\n      <color rgba="0.1 0.1 0.1 1.0"/>\n    </material>\n  </visual>\n  <collision>\n    <geometry>\n      <box size="0.2 0.1 0.05"/>\n    </geometry>\n  </collision>\n  <inertial>\n    <mass value="1.0"/>\n    <inertia ixx="0.001" ixy="0.0" ixz="0.0" iyy="0.002" iyz="0.0" izz="0.002"/>\n  </inertial>\n</link>\n\n<gazebo reference="left_foot">\n  \x3c!-- Visual properties --\x3e\n  <material>Gazebo/Black</material>\n\n  \x3c!-- Collision properties optimized for walking --\x3e\n  <collision name="left_foot_collision">\n    <surface>\n      <contact>\n        <ode>\n          <soft_cfm>0.0001</soft_cfm>\n          <soft_erp>0.9</soft_erp>\n          <kp>1e8</kp>\n          <kd>1e4</kd>\n          <max_vel>100.0</max_vel>\n          <min_depth>0.0005</min_depth>\n        </ode>\n      </contact>\n      <friction>\n        <ode>\n          <mu>0.9</mu>\n          <mu2>0.9</mu2>\n        </ode>\n      </friction>\n    </surface>\n  </collision>\n\n  \x3c!-- Contact sensor for ground contact detection --\x3e\n  <sensor name="left_foot_contact" type="contact">\n    <always_on>true</always_on>\n    <update_rate>200</update_rate>\n    <contact>\n      <collision>left_foot_collision</collision>\n    </contact>\n  </sensor>\n</gazebo>\n'})}),"\n",(0,t.jsx)(e.h2,{id:"exercises",children:"Exercises"}),"\n",(0,t.jsx)(e.h3,{id:"exercise-1-basic-humanoid-robot-model",children:"Exercise 1: Basic Humanoid Robot Model"}),"\n",(0,t.jsx)(e.p,{children:"Create a simple humanoid robot model with at least 5 links and 4 joints in Gazebo:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Design a robot with pelvis, torso, head, and two arms"}),"\n",(0,t.jsx)(e.li,{children:"Implement proper URDF with visual, collision, and inertial properties"}),"\n",(0,t.jsx)(e.li,{children:"Add Gazebo-specific tags for visualization and physics"}),"\n",(0,t.jsx)(e.li,{children:"Test the model in Gazebo to ensure it's stable and properly configured"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"exercise-2-physics-parameter-tuning",children:"Exercise 2: Physics Parameter Tuning"}),"\n",(0,t.jsx)(e.p,{children:"Adjust physics parameters to achieve stable behavior:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Experiment with different ERP and CFM values to find stable configurations"}),"\n",(0,t.jsx)(e.li,{children:"Tune joint damping and friction for realistic movement"}),"\n",(0,t.jsx)(e.li,{children:"Test the robot's response to external forces"}),"\n",(0,t.jsx)(e.li,{children:"Document the optimal parameters for your specific robot model"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"exercise-3-collision-detection-and-response",children:"Exercise 3: Collision Detection and Response"}),"\n",(0,t.jsx)(e.p,{children:"Implement comprehensive collision detection:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Add contact sensors to feet and hands for environmental interaction"}),"\n",(0,t.jsx)(e.li,{children:"Configure surface properties for realistic ground contact"}),"\n",(0,t.jsx)(e.li,{children:"Test collision detection between robot and environment objects"}),"\n",(0,t.jsx)(e.li,{children:"Implement a simple balance controller using contact feedback"}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"exercise-4-advanced-joint-control",children:"Exercise 4: Advanced Joint Control"}),"\n",(0,t.jsx)(e.p,{children:"Implement sophisticated joint control:"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsx)(e.li,{children:"Set up ROS control interfaces for your robot"}),"\n",(0,t.jsx)(e.li,{children:"Create position, velocity, and effort controllers"}),"\n",(0,t.jsx)(e.li,{children:"Test different control strategies (position, velocity, effort)"}),"\n",(0,t.jsx)(e.li,{children:"Implement a simple walking pattern using joint trajectories"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(e.p,{children:"This chapter introduced the fundamentals of physics simulation with Gazebo for humanoid robots. We covered physics engines, URDF integration, joint constraints, and collision detection. Proper physics simulation is crucial for developing and testing humanoid robot behaviors in a safe, controlled environment. The next chapter will explore digital twins and HRI in Unity."})]})}function h(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8453(n,e,i){i.d(e,{R:()=>r,x:()=>l});var o=i(6540);const t={},s=o.createContext(t);function r(n){const e=o.useContext(s);return o.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:r(n.components),o.createElement(s.Provider,{value:e},n.children)}}}]);