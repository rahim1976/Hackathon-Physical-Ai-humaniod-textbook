"use strict";(globalThis.webpackChunkai_spec_driven_book_with_rag_chatbot_frontend=globalThis.webpackChunkai_spec_driven_book_with_rag_chatbot_frontend||[]).push([[895],{5592(e,n,s){s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>t,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"ros2-humanoid/communication-model","title":"ROS 2 Communication Model","description":"Understanding Nodes","source":"@site/docs/ros2-humanoid/communication-model.md","sourceDirName":"ros2-humanoid","slug":"/ros2-humanoid/communication-model","permalink":"/docs/ros2-humanoid/communication-model","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/ros2-humanoid/communication-model.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Introduction to ROS 2 for Physical AI","permalink":"/docs/ros2-humanoid/intro-to-ros2"},"next":{"title":"Robot Structure with URDF","permalink":"/docs/ros2-humanoid/robot-structure-urdf"}}');var o=s(4848),i=s(8453);const t={sidebar_position:2},a="ROS 2 Communication Model",l={},c=[{value:"Understanding Nodes",id:"understanding-nodes",level:2},{value:"Creating a Node with rclpy",id:"creating-a-node-with-rclpy",level:3},{value:"Topics and Publishers/Subscribers",id:"topics-and-publisherssubscribers",level:2},{value:"Publishers",id:"publishers",level:3},{value:"Subscribers",id:"subscribers",level:3},{value:"Services",id:"services",level:2},{value:"Creating a Service Server",id:"creating-a-service-server",level:3},{value:"Creating a Service Client",id:"creating-a-service-client",level:3},{value:"Actions",id:"actions",level:2},{value:"Action Server Example",id:"action-server-example",level:3},{value:"Basic rclpy-based Agent Controller Flow",id:"basic-rclpy-based-agent-controller-flow",level:2},{value:"Quality of Service (QoS) Considerations for Humanoid Robotics",id:"quality-of-service-qos-considerations-for-humanoid-robotics",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"ros-2-communication-model",children:"ROS 2 Communication Model"})}),"\n",(0,o.jsx)(n.h2,{id:"understanding-nodes",children:"Understanding Nodes"}),"\n",(0,o.jsx)(n.p,{children:"In ROS 2, a node is the fundamental unit of execution. It's a process that performs computation and communicates with other nodes through the ROS graph. For humanoid robots, nodes represent different functional components:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Sensor nodes"}),": Handle data from cameras, IMUs, joint encoders, etc."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Controller nodes"}),": Manage robot motion and control algorithms"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Perception nodes"}),": Process sensor data to understand the environment"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Planning nodes"}),": Generate motion plans and trajectories"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Behavior nodes"}),": Coordinate high-level robot behaviors"]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"creating-a-node-with-rclpy",children:"Creating a Node with rclpy"}),"\n",(0,o.jsx)(n.p,{children:"The Python client library for ROS 2 (rclpy) provides the tools to create nodes. Here's a basic example of a node structure:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\n\nclass HumanoidControllerNode(Node):\n    def __init__(self):\n        super().__init__('humanoid_controller')\n        # Initialize publishers, subscribers, services, etc.\n        self.get_logger().info('Humanoid Controller Node initialized')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = HumanoidControllerNode()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,o.jsx)(n.h2,{id:"topics-and-publisherssubscribers",children:"Topics and Publishers/Subscribers"}),"\n",(0,o.jsx)(n.p,{children:"Topics enable asynchronous, many-to-many communication in ROS 2. Data is published to a topic and any number of nodes can subscribe to receive that data."}),"\n",(0,o.jsx)(n.h3,{id:"publishers",children:"Publishers"}),"\n",(0,o.jsx)(n.p,{children:"A publisher sends messages to a topic. Here's an example of publishing joint commands for a humanoid robot:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nimport math\n\nclass JointCommandPublisher(Node):\n    def __init__(self):\n        super().__init__('joint_command_publisher')\n        self.publisher = self.create_publisher(JointState, 'joint_commands', 10)\n        self.timer = self.create_timer(0.1, self.publish_joint_commands)  # 10Hz\n        self.step = 0\n\n    def publish_joint_commands(self):\n        msg = JointState()\n        msg.name = ['left_hip', 'left_knee', 'left_ankle', 'right_hip', 'right_knee', 'right_ankle']\n\n        # Generate simple oscillating joint commands\n        positions = []\n        for i in range(6):\n            pos = math.sin(self.step * 0.1 + i) * 0.5\n            positions.append(pos)\n\n        msg.position = positions\n        msg.header.stamp = self.get_clock().now().to_msg()\n        self.publisher.publish(msg)\n        self.step += 1\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = JointCommandPublisher()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,o.jsx)(n.h3,{id:"subscribers",children:"Subscribers"}),"\n",(0,o.jsx)(n.p,{children:"A subscriber receives messages from a topic. Here's an example of subscribing to sensor data:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import Float64\n\nclass SensorProcessor(Node):\n    def __init__(self):\n        super().__init__('sensor_processor')\n        self.subscription = self.create_subscription(\n            JointState,\n            'joint_states',\n            self.listener_callback,\n            10)\n        self.subscription  # prevent unused variable warning\n\n        # Publisher for processed data\n        self.error_publisher = self.create_publisher(Float64, 'position_error', 10)\n\n    def listener_callback(self, msg):\n        self.get_logger().info(f'Received joint states: {len(msg.name)} joints')\n\n        # Process the sensor data (example: calculate position error)\n        error_msg = Float64()\n        error_msg.data = 0.0  # Placeholder for actual error calculation\n        self.error_publisher.publish(error_msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = SensorProcessor()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,o.jsx)(n.h2,{id:"services",children:"Services"}),"\n",(0,o.jsx)(n.p,{children:"Services provide synchronous, request-response communication. This is useful for operations that have a clear beginning and end, such as calibration or configuration changes."}),"\n",(0,o.jsx)(n.h3,{id:"creating-a-service-server",children:"Creating a Service Server"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.srv import SetBool\n\nclass CalibrationService(Node):\n    def __init__(self):\n        super().__init__('calibration_service')\n        self.srv = self.create_service(\n            SetBool,\n            'calibrate_robot',\n            self.calibrate_robot_callback)\n        self.calibrated = False\n\n    def calibrate_robot_callback(self, request, response):\n        if request.data:  # If request is to calibrate\n            self.get_logger().info('Starting robot calibration...')\n            # Perform calibration (simplified)\n            self.calibrated = True\n            response.success = True\n            response.message = 'Robot calibration completed successfully'\n        else:\n            response.success = False\n            response.message = 'Calibration request rejected'\n\n        return response\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = CalibrationService()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,o.jsx)(n.h3,{id:"creating-a-service-client",children:"Creating a Service Client"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.srv import SetBool\n\nclass CalibrationClient(Node):\n    def __init__(self):\n        super().__init__('calibration_client')\n        self.cli = self.create_client(SetBool, 'calibrate_robot')\n        while not self.cli.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Service not available, waiting again...')\n        self.req = SetBool.Request()\n\n    def send_request(self, calibrate=True):\n        self.req.data = calibrate\n        self.future = self.cli.call_async(self.req)\n        rclpy.spin_until_future_complete(self, self.future)\n        return self.future.result()\n\ndef main(args=None):\n    rclpy.init(args=args)\n    client = CalibrationClient()\n    response = client.send_request(True)\n\n    if response:\n        print(f'Result: {response.success}, Message: {response.message}')\n    else:\n        print('Service call failed')\n\n    client.destroy_node()\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,o.jsx)(n.h2,{id:"actions",children:"Actions"}),"\n",(0,o.jsx)(n.p,{children:"Actions are designed for long-running tasks that might be preempted. They're ideal for humanoid robot tasks like navigation, manipulation, or complex motion sequences."}),"\n",(0,o.jsx)(n.h3,{id:"action-server-example",children:"Action Server Example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.action import ActionServer\nfrom rclpy.node import Node\nfrom example_interfaces.action import Fibonacci\n\nclass FibonacciActionServer(Node):\n    def __init__(self):\n        super().__init__('fibonacci_action_server')\n        self._action_server = ActionServer(\n            self,\n            Fibonacci,\n            'fibonacci',\n            self.execute_callback)\n\n    def execute_callback(self, goal_handle):\n        self.get_logger().info('Executing goal...')\n\n        feedback_msg = Fibonacci.Feedback()\n        feedback_msg.sequence = [0, 1]\n\n        for i in range(1, goal_handle.request.order):\n            if goal_handle.is_cancel_requested:\n                goal_handle.canceled()\n                self.get_logger().info('Goal canceled')\n                return Fibonacci.Result()\n\n            feedback_msg.sequence.append(\n                feedback_msg.sequence[i] + feedback_msg.sequence[i-1])\n\n            goal_handle.publish_feedback(feedback_msg)\n            self.get_logger().info(f'Feedback: {feedback_msg.sequence}')\n\n        goal_handle.succeed()\n        result = Fibonacci.Result()\n        result.sequence = feedback_msg.sequence\n        return result\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = FibonacciActionServer()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,o.jsx)(n.h2,{id:"basic-rclpy-based-agent-controller-flow",children:"Basic rclpy-based Agent Controller Flow"}),"\n",(0,o.jsx)(n.p,{children:"A humanoid robot controller typically follows this flow pattern:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Initialization"}),": Set up ROS 2 node, publishers, subscribers, timers"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Sensor Data Acquisition"}),": Subscribe to sensor topics or request data"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"State Estimation"}),": Process sensor data to understand robot state"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Planning/Decision Making"}),": Determine desired actions based on state and goals"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Control Output"}),": Publish commands to actuators"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Loop"}),": Repeat steps 2-5 at the required frequency"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Here's a complete example of a simple humanoid balance controller:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import Imu, JointState\nfrom std_msgs.msg import Float64MultiArray\nimport numpy as np\n\nclass BalanceController(Node):\n    def __init__(self):\n        super().__init__('balance_controller')\n\n        # Subscribers for sensor data\n        self.imu_sub = self.create_subscription(\n            Imu, 'imu/data', self.imu_callback, 10)\n        self.joint_sub = self.create_subscription(\n            JointState, 'joint_states', self.joint_callback, 10)\n\n        # Publisher for joint commands\n        self.command_pub = self.create_publisher(\n            Float64MultiArray, 'joint_commands', 10)\n\n        # Timer for control loop\n        self.control_timer = self.create_timer(0.01, self.control_loop)  # 100Hz\n\n        # Internal state\n        self.current_imu = None\n        self.current_joints = None\n        self.target_positions = [0.0] * 12  # Example: 12 joints\n\n    def imu_callback(self, msg):\n        self.current_imu = msg\n\n    def joint_callback(self, msg):\n        self.current_joints = msg\n\n    def control_loop(self):\n        if self.current_imu is None or self.current_joints is None:\n            return  # Wait for sensor data\n\n        # Simple balance control (simplified example)\n        roll = self.current_imu.orientation.x\n        pitch = self.current_imu.orientation.y\n\n        # Adjust target based on balance error\n        self.target_positions[0] += pitch * 0.1  # Adjust hip joints based on pitch\n        self.target_positions[1] -= roll * 0.1   # Adjust based on roll\n\n        # Publish commands\n        cmd_msg = Float64MultiArray()\n        cmd_msg.data = self.target_positions\n        self.command_pub.publish(cmd_msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = BalanceController()\n\n    try:\n        rclpy.spin(node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,o.jsx)(n.h2,{id:"quality-of-service-qos-considerations-for-humanoid-robotics",children:"Quality of Service (QoS) Considerations for Humanoid Robotics"}),"\n",(0,o.jsx)(n.p,{children:"Different types of data in humanoid robots require different QoS settings:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Sensor data"}),": Usually RELIABLE with small history for real-time processing"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Control commands"}),": RELIABLE with small history to ensure commands are received"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Debug information"}),": BEST_EFFORT with small history to reduce overhead"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Configuration data"}),": RELIABLE with TRANSIENT_LOCAL durability so new nodes get current config"]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(n.p,{children:"The ROS 2 communication model provides flexible and robust ways to connect different parts of a humanoid robot system. Understanding nodes, topics, services, and actions is crucial for building effective robot controllers. The rclpy library provides Python access to all these communication patterns, making it accessible for AI developers to implement complex humanoid robot behaviors."})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453(e,n,s){s.d(n,{R:()=>t,x:()=>a});var r=s(6540);const o={},i=r.createContext(o);function t(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:t(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);